{
  "conversion_prompt": {
    "title": "TypeScript to React JS Conversion Prompt",
    "version": "1.0",
    "purpose": "Convert TypeScript/TSX code to React JS (JavaScript) and ensure all future frontend code is written in React JS",
    "instructions": {
      "primary_objective": "Convert all TypeScript (.tsx, .ts) code to React JS (.jsx, .js) format while maintaining functionality and React best practices",
      "conversion_rules": {
        "file_extensions": {
          "typescript_react": ".tsx → .jsx",
          "typescript": ".ts → .js",
          "note": "Keep all other file extensions unchanged (.json, .css, .md, etc.)"
        },
        "type_annotations": {
          "remove_all": true,
          "examples": {
            "variable": "const name: string = 'value' → const name = 'value'",
            "function": "function greet(name: string): string → function greet(name)",
            "arrow_function": "const add = (a: number, b: number): number => → const add = (a, b) =>",
            "array": "const items: string[] = [] → const items = []",
            "object": "const user: { name: string; age: number } → const user = { name: '', age: 0 }"
          }
        },
        "interfaces_and_types": {
          "action": "remove_completely",
          "alternative": "Use JSDoc comments for documentation if needed",
          "example": {
            "before": "interface User { id: string; name: string; }",
            "after": "/** @typedef {Object} User @property {string} id @property {string} name */",
            "note": "JSDoc is optional - can be removed entirely if not needed"
          }
        },
        "type_imports": {
          "action": "convert_to_regular_imports",
          "examples": {
            "before": "import type { User, Document } from './interfaces'",
            "after": "import { User, Document } from './interfaces'",
            "note": "If interfaces are removed, remove these imports entirely"
          }
        },
        "type_assertions": {
          "action": "remove",
          "examples": {
            "before": "const doc = item as Document",
            "after": "const doc = item",
            "before": "const user = <User>data",
            "after": "const user = data"
          }
        },
        "generic_types": {
          "action": "remove",
          "examples": {
            "before": "function useState<T>(initial: T): [T, (value: T) => void]",
            "after": "function useState(initial)",
            "before": "const [data, setData] = useState<Document[]>([])",
            "after": "const [data, setData] = useState([])"
          }
        },
        "optional_chaining": {
          "action": "keep_as_is",
          "note": "Optional chaining (?.) and nullish coalescing (??) are valid JavaScript - keep them"
        },
        "default_parameters": {
          "action": "keep_as_is",
          "example": "function greet(name = 'Guest') { } // Keep this"
        },
        "destructuring": {
          "action": "keep_as_is",
          "note": "All destructuring patterns remain unchanged"
        },
        "react_hooks": {
          "action": "remove_type_annotations_only",
          "examples": {
            "useState": "const [count, setCount] = useState<number>(0) → const [count, setCount] = useState(0)",
            "useEffect": "useEffect(() => { }, []) // Keep dependency arrays",
            "useMemo": "const memo = useMemo<number>(() => { }, []) → const memo = useMemo(() => { }, [])",
            "useCallback": "const cb = useCallback<(id: string) => void>(() => { }, []) → const cb = useCallback(() => { }, [])"
          }
        },
        "props_definition": {
          "action": "convert_to_proptypes_or_remove",
          "options": {
            "option_1": "Remove prop types entirely (simpler)",
            "option_2": "Use PropTypes (add prop-types package)",
            "example_proptypes": "import PropTypes from 'prop-types'; Component.propTypes = { name: PropTypes.string.isRequired }"
          },
          "examples": {
            "before": "interface ButtonProps { onClick: () => void; children: React.ReactNode; }",
            "after": "// Props are just function parameters - no type definition needed",
            "before": "const Button = ({ onClick, children }: ButtonProps) => { }",
            "after": "const Button = ({ onClick, children }) => { }"
          }
        },
        "event_handlers": {
          "action": "remove_types",
          "examples": {
            "before": "const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => { }",
            "after": "const handleClick = (e) => { }",
            "before": "onChange={(e: React.ChangeEvent<HTMLInputElement>) => { }}",
            "after": "onChange={(e) => { }}"
          }
        },
        "api_responses": {
          "action": "remove_types_use_javascript_validation",
          "example": {
            "before": "const response: ApiResponse<User> = await fetchUser()",
            "after": "const response = await fetchUser()",
            "validation": "Add runtime validation if needed: if (!response || !response.id) { throw new Error('Invalid response') }"
          }
        }
      },
      "code_structure_rules": {
        "imports": {
          "react": "Keep: import React from 'react'",
          "named_imports": "Keep: import { useState, useEffect } from 'react'",
          "third_party": "Keep all third-party imports unchanged",
          "relative_imports": "Update paths if file extensions change"
        },
        "exports": {
          "default": "export default Component",
          "named": "export const Component = () => { }",
          "note": "Keep all export patterns unchanged"
        },
        "jsx_syntax": {
          "action": "keep_unchanged",
          "note": "JSX syntax is identical in TSX and JSX files"
        },
        "comments": {
          "action": "keep_all_comments",
          "note": "Preserve all existing comments and documentation"
        }
      },
      "configuration_changes": {
        "package_json": {
          "remove": [
            "typescript",
            "@types/react",
            "@types/react-dom",
            "@types/node",
            "@typescript-eslint/eslint-plugin",
            "@typescript-eslint/parser"
          ],
          "add_if_needed": [
            "prop-types (optional, for PropTypes validation)"
          ],
          "update_scripts": {
            "build": "vite build (remove 'tsc &&' prefix)",
            "lint": "eslint . --ext js,jsx (change from ts,tsx)"
          }
        },
        "tsconfig_json": {
          "action": "delete_file",
          "note": "No longer needed for JavaScript project"
        },
        "vite_config": {
          "action": "update_if_needed",
          "note": "Vite works with JS/JSX out of the box, may need to update plugin config"
        },
        "eslint_config": {
          "action": "update_parser",
          "change": "parser: '@typescript-eslint/parser' → parser: '@babel/eslint-parser' or 'espree'"
        }
      },
      "file_conversion_checklist": {
        "for_each_file": [
          "1. Rename file extension (.tsx → .jsx, .ts → .js)",
          "2. Remove all type annotations",
          "3. Remove interface/type definitions",
          "4. Convert 'import type' to regular imports or remove",
          "5. Remove type assertions (as Type)",
          "6. Remove generic type parameters (<T>)",
          "7. Update relative imports if file paths changed",
          "8. Verify all React hooks work without types",
          "9. Test that component renders correctly",
          "10. Ensure no TypeScript-specific syntax remains"
        ]
      },
      "future_code_generation_rules": {
        "language": "Always use React JS (JavaScript) - NEVER TypeScript",
        "file_extensions": "Always use .jsx for React components, .js for utilities",
        "code_style": {
          "use_functional_components": true,
          "use_react_hooks": true,
          "use_arrow_functions": "preferred but not required",
          "naming_convention": "camelCase for variables/functions, PascalCase for components"
        },
        "examples": {
          "component": "const MyComponent = ({ prop1, prop2 }) => { return <div>{prop1}</div> }",
          "hook": "const useCustomHook = () => { const [state, setState] = useState(null); return { state, setState }; }",
          "utility": "export const formatDate = (date) => { return new Date(date).toLocaleDateString(); }"
        },
        "never_include": [
          "Type annotations (: string, : number, etc.)",
          "Interface definitions",
          "Type assertions (as Type)",
          "Generic types (<T>)",
          "'import type' statements",
          "TypeScript-specific syntax"
        ]
      },
      "validation_rules": {
        "after_conversion": [
          "All files should have .jsx or .js extensions",
          "No type annotations should remain",
          "No interface/type definitions should remain",
          "All imports should work (update paths if needed)",
          "Code should run without TypeScript compiler",
          "React components should render correctly",
          "All functionality should be preserved"
        ]
      },
      "common_patterns_conversion": {
        "pattern_1": {
          "name": "Component with Props",
          "typescript": "interface Props { name: string; age: number; }\nconst Component = ({ name, age }: Props) => { }",
          "javascript": "const Component = ({ name, age }) => { }"
        },
        "pattern_2": {
          "name": "State with Type",
          "typescript": "const [user, setUser] = useState<User | null>(null)",
          "javascript": "const [user, setUser] = useState(null)"
        },
        "pattern_3": {
          "name": "Event Handler",
          "typescript": "const handleClick = (e: React.MouseEvent) => { }",
          "javascript": "const handleClick = (e) => { }"
        },
        "pattern_4": {
          "name": "API Call",
          "typescript": "const fetchData = async (): Promise<Data[]> => { }",
          "javascript": "const fetchData = async () => { }"
        },
        "pattern_5": {
          "name": "useMemo with Type",
          "typescript": "const memo = useMemo<number>(() => value * 2, [value])",
          "javascript": "const memo = useMemo(() => value * 2, [value])"
        }
      },
      "special_considerations": {
        "mock_data": {
          "action": "keep_json_files_unchanged",
          "note": "JSON files don't need conversion"
        },
        "css_files": {
          "action": "keep_unchanged",
          "note": "CSS/SCSS files remain the same"
        },
        "configuration_files": {
          "action": "update_as_per_configuration_changes_section",
          "files": ["package.json", "vite.config.js", ".eslintrc", "etc."]
        },
        "third_party_libraries": {
          "action": "keep_imports_unchanged",
          "note": "All third-party library imports work the same in JS"
        }
      }
    },
    "usage_instructions": {
      "step_1": "Use this prompt as a reference when converting TypeScript files",
      "step_2": "Apply conversion rules systematically to each file",
      "step_3": "For future code generation, always specify: 'Write in React JS (JavaScript), not TypeScript'",
      "step_4": "Include this prompt context when asking for new React code",
      "step_5": "Validate converted code follows all rules in validation_rules section"
    },
    "example_prompt_for_ai": "Convert the following TypeScript code to React JS following these rules: [paste conversion rules]. Remove all type annotations, interfaces, and TypeScript-specific syntax. Output pure JavaScript/React JS code.",
    "example_prompt_for_new_code": "Create a new React component in React JS (JavaScript, not TypeScript). Use .jsx extension, no type annotations, no interfaces. Follow React best practices with functional components and hooks."
  }
}

